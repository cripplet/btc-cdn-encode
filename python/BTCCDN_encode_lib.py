from decimal import Decimal as decimal
import os
import bitcoin
from bitcoin.rpc import Proxy as btc_proxy
from bitcoin.wallet import P2PKHBitcoinAddress as btc_address
from bitcoin.core import x as btc_x
from bitcoin.core import lx as btc_lx
from bitcoin.core import b2lx as btc_btolx
import json
import struct
import binascii

from pprint import pprint

# https://bitcoin.org/en/developer-reference

MIN_TAX = 1000
MAX_DATA = 40
LEN_HEAD = 1
VERSION = 0

class InsufficientFunds(Exception):
	pass

# handler for binary data generated by using generaterawtransaction
class RawTx:
	# binary data stream
	# raw is hex-encoded data as generated by generaterawtransaction
	# blob is the binary-decoded unicode string of raw
	class BinaryStream:
		def __init__(self, raw):
			self._b = raw.decode('hex')
			self._p = 0

		@property
		def blob(self):
			return self._b

		def skip(self, n):
			self._p += n

		def unpack(self, format, n):
			r = struct.unpack_from(format, self.blob, self._p)
			self.skip(n)
			return r

		def unpack_hex(self, n):
			_result = binascii.b2a_hex(self.blob[self._p:self._p + n])
			_result = ''.join([ _result[i:i + 2] for i in range(0, len(_result), 2) ][::-1])
			self.skip(n)
			return _result

		def unpack_txid(self):
			return self.unpack_hex(32)

		def unpack_varint(self):
			f = self.unpack('<B', 1)[0]
			if f == 0xff:
				f = self.unpack('<Q', 8)[0]
			elif f == 0xfe:
				f = self.unpack('<I', 4)[0]
			elif f == 0xfd:
				f = self.unpack('<H', 2)[0]
			return f

		def reset(self):
			self._p = 0

	def __init__(self, proxy, raw):
		self._r = raw
		self._stream = RawTx.BinaryStream(self.raw)
		self._proxy = proxy

	@property
	def raw(self):
		return self._r

	@property
	def proxy(self):
		return self._proxy

	@property
	def json(self):
		return self.proxy.decoderawtransaction(self.raw)

	# take the raw transaction and turn into an array of referrable data
	def unpack(self):
		self._stream.reset()
		d = { 'version' : self._stream.unpack('<L', 4)[0], 'vin' : [], 'vout' : [] }
		for x in xrange(self._stream.unpack_varint()):
			d['vin'].append({
				'txid' : self._stream.unpack_txid(),
				'vout' : self._stream.unpack('<L', 4)[0],
				'scriptSig' : self._stream.unpack_hex(self._stream.unpack_varint()),
				'sequence' : self._stream.unpack('<L', 4)[0],
			})
		for x in xrange(self._stream.unpack_varint()):
			d['vout'].append({
				'value' : self._stream.unpack('<Q', 8)[0] * 10 ** -8,
				'scriptPubKey' : self._stream.unpack_hex(self._stream.unpack_varint()),
			})
		d['locktime'] = self._stream.unpack('<L', 4)[0]
		return d

	def pack(self, d):
		pass

class OPReturnTx:
	global MAX_DATA
	##
	# src and dest are bitcoin addresses; src may be '' to indicate no preference on single input
	# msg is binary data
	##
	def __init__(self, src, dest, msg):
		assert(len(msg) <= MAX_DATA)
		self._s = src
		self._d = dest
		self._m = msg

	@property
	def proxy(self):
		if not getattr(OPReturnTx, '_proxy', None):
			self._proxy = btc_proxy()
		return self._proxy

	# returns list of inputs to use for the transaction
	# if self._s is specified, use ONLY funds in self._s for transaction
	def _i(self, v, t):
		candidates = self.proxy.listunspent()
		if self._s != '':
			candidates = filter(lambda x: x['address'] == btc_address(self._s), candidates)
		# highest number of confirmations should be listed first as preferred spending account
		candidates = sorted(candidates, lambda x, y: cmp(y['confirmations'], x['confirmations']))
		input = []
		total = 0
		for c in candidates:
			if total < v + t:
				input.append({ 'txid' : btc_btolx(c['outpoint'].hash), 'vout' : c['outpoint'].n } )
				total += c['amount']
		if total < v:
			raise InsufficientFunds
		return (input, total)

	# returns a dict of { address : amount } outputs
	# if self._s == '', create a new change address, otherwise send change back to self._src
	def _o(self, s, v, t, input):
		output = { self._d : s - t if self._s == self._d else v }
		if self._s == '':
			output[self.proxy.getrawchangeaddress().__str__()] = s - v - t
		for k in output:
			output[k] = output[k] * 10 ** -8
		return output

	# creates the transaction to send
	# cf. http://bitcoin.stackexchange.com/questions/25224/what-is-a-step-by-step-way-to-insert-data-in-op-return for how to implement on TESTNET
	# cf. https://github.com/coinspark/php-OP_RETURN for implementation on MAINNET in PHP
	def _create(self, i, o):
		tx = RawTx(self.proxy, self.proxy.createrawtransaction(i, o))
		pprint(tx.json)
		# print tx
		# pprint(self.proxy.decoderawtransaction(tx))
		return tx

	# return txid
	# amt and tax are both in satoshi units
	def send(self, amt, tax):
		(i, s) = self._i(amt, tax)
		o = self._o(s, amt, tax, i)
		tx = self._create(i, o)
		r = tx.unpack()

# OPReturnTx('', '1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', 'Hello world!').send(1000, MIN_TAX)
OPReturnTx('1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', '1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', 'Hello world!').send(1000, MIN_TAX)

class BTCCDNCommand:
	global VERSION
	COMMAND = {
		'MSG' : 32,
		'FILESTART' : 33,
		'FILETERM' : 34,
		'TERMACCT' : 34
	}
	v = VERSION

	# cmd is a string input
	# payload is array (?)
	def __init__(self, cmd, payload):
		global MAX_LENGTH
		assert(cmd in self.COMMAND)
		# ? assert(len(payload) <= MAX_DATA - LEN_HEAD)
		self._c = self.COMMAND[cmd]
		self._p = payload

	@property
	def command(self):
		for k, v in self.COMMAND:
			if self._c == v:
				return k

	@property
	def payload(self):
		return self._p

	@property
	def header(self):
		return self.v << 5 | self._c
		

class AddrLog:
	global MIN_TAX
	tax = MIN_TAX
	def __init__(self, address):
		self._addr = address
		# if log file does not exist, create it, get count
		self.count = 0

	@property
	def count(self):
		return self._c

	@count.setter
	def count(self, v):
		self._c = v
		# write to file

	@property
	def address(self):
		return self._addr

	# return how much spending potential the current ADDRESS has
	@property
	def funds(self):
		return 0

	# sends data to destination address; if final = True, terminate this account
	def send(self, dest, data):
		# check insufficient funds

		# lock funds

		# send
		tx = []
		# for ...
		tx.append(OPReturnTx(self.address, dest, data[0::1]).send(0, self.tax))

		self.c += 0
		pass
		# unlock funds

	def term(self, next=''):
		# lock funds
		OPReturnTx(self.address, self.address, next).send(0, self.tax)
		pass
		# unlock funds

class File:
	def __init__(self, name):
		self._fn = name

	@property
	def name(self):
		return self._fn

	# returns the size of the file in bytes
	@property
	def size(self):
		return os.stat(self.name).st_size

	@property
	def data(self):
		return ''

	# sends self to the target address dest, with any leftover funds going to address change
	# throws NoFunds exception if insufficient funds
	# returns first txid of the transaction
	def send(self, change, dest):
		return AddrLog(change).send(dest, self.data)
