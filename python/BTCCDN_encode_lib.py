import os
import json
import struct
import binascii

from decimal import Decimal as decimal

import bitcoin

from bitcoin.rpc import Proxy as btc_proxy
from bitcoin.wallet import P2PKHBitcoinAddress as btc_address
from bitcoin.core.script import CScriptOp # OP_PUSHDATA1, OP_PUSHDATA2
from bitcoin.core import b2lx as btc_btolx


# debug
from pprint import pprint

# https://bitcoin.org/en/developer-reference

MIN_TAX = 1000
MAX_DATA = 40
LEN_HEAD = 1
VERSION = 0

class InsufficientFunds(Exception):
	pass

# handler for binary data generated by using generaterawtransaction
class RawTx(object):
	# binary data stream
	# raw is hex-encoded data as generated by generaterawtransaction
	# blob is the binary-decoded unicode string of raw
	class BinaryStream(object):
		def __init__(self, raw):
			self._b = raw.decode('hex')
			self._p = 0

		@property
		def blob(self):
			return self._b

		def skip(self, n):
			self._p += n

		def pack(self, format, d):
			r = struct.pack(format, d)
			self._b += r
			return r

		def unpack(self, format, n):
			r = struct.unpack_from(format, self.blob, self._p)
			self.skip(n)
			return r

		@staticmethod
		def _pack_hex(s):
			s = ''.join([ s[i:i + 2] for i in range(0, len(s), 2) ][::-1])
			r = binascii.a2b_hex(s)
			return r			

		@staticmethod
		def _unpack_hex(s):
			r = binascii.b2a_hex(s)
			r = ''.join([ r[i:i + 2] for i in range(0, len(r), 2) ][::-1])
			return r

		def pack_hex(self, s):
			r = RawTx.BinaryStream._pack_hex(s)
			self._b += r
			return r

		def unpack_hex(self, n):
			r = RawTx.BinaryStream._unpack_hex(self.blob[self._p:self._p + n])
			self.skip(n)
			return r

		def pack_txid(self, txid):
			return self.pack_hex(txid)

		def unpack_txid(self):
			return self.unpack_hex(32)

		def pack_varint(self, f):
			if f > 0xffffffff:
				r = '\xff' + struct.pack('<Q', f)
			elif f > 0xffff:
				r = '\xfe' + struct.pack('<I', f)
			elif f > 0xfc:
				r = '\xfd' + struct.pack('<H', f)
			else:
				r = struct.pack('<B', f)
			self._b += r
			return r

		def unpack_varint(self):
			f = self.unpack('<B', 1)[0]
			if f == 0xff:
				f = self.unpack('<Q', 8)[0]
			elif f == 0xfe:
				f = self.unpack('<I', 4)[0]
			elif f == 0xfd:
				f = self.unpack('<H', 2)[0]
			return f

		def reset(self):
			self._p = 0

	def __init__(self, proxy, raw):
		self._r = raw
		self._stream = RawTx.BinaryStream(self.raw)
		self._proxy = proxy

	@property
	def stream(self):
		return self._stream

	@stream.setter
	def stream(self, s):
		self._stream = s
		self._r = s.blob.encode('hex')

	@property
	def raw(self):
		return self._r

	@property
	def proxy(self):
		return self._proxy

	@property
	def json(self):
		return self.proxy.decoderawtransaction(self.raw)

	# take the raw transaction and turn into an array of referrable data
	def unpack(self):
		self.stream.reset()
		d = { 'version' : self.stream.unpack('<L', 4)[0], 'vin' : [], 'vout' : [] }
		for x in xrange(self.stream.unpack_varint()):
			d['vin'].append({
				'txid' : self.stream.unpack_txid(),
				'vout' : self.stream.unpack('<L', 4)[0],
				'scriptSig' : self.stream.unpack_hex(self.stream.unpack_varint()),
				'sequence' : self.stream.unpack('<L', 4)[0],
			})
		for x in xrange(self.stream.unpack_varint()):
			d['vout'].append({
				'value' : self.stream.unpack('<Q', 8)[0] * 10 ** -8,
				'scriptPubKey' : self.stream.unpack_hex(self.stream.unpack_varint()),
			})
		d['locktime'] = self.stream.unpack('<L', 4)[0]
		return d

	def pack(self, d):
		s = RawTx.BinaryStream('')
		s.pack('<L', d['version'])
		s.pack_varint(len(d['vin']))
		for x in d['vin']:
			s.pack_txid(x['txid'])
			s.pack('<L', x['vout'])
			s.pack_varint(len(x['scriptSig']) / 2)
			s.pack_hex(x['scriptSig'])
			s.pack('<L', x['sequence'])
		s.pack_varint(len(d['vout']))
		for x in d['vout']:
			s.pack('<Q', x['value'] * 10 ** 8)
			s.pack_varint(len(x['scriptPubKey']) / 2)
			s.pack_hex(x['scriptPubKey'])
		s.pack('<L', d['locktime'])
		self.stream = s

class OPReturnTx(object):
	global MAX_DATA
	##
	# src and dest are bitcoin addresses; src may be '' to indicate no preference on single input
	# msg is binary data
	##
	def __init__(self, src, dest, msg):
		assert(len(msg) <= MAX_DATA)
		self._s = src
		self._d = dest
		self._m = msg

	@property
	def msg(self):
		return self._m

	@property
	def src(self):
		return self._s

	@property
	def dest(self):
		return self._d

	@property
	def proxy(self):
		if not getattr(OPReturnTx, '_proxy', None):
			self._proxy = btc_proxy()
		return self._proxy

	# returns list of inputs to use for the transaction
	# if self._s is specified, use ONLY funds in self._s for transaction
	def _i(self, v, t):
		candidates = self.proxy.listunspent()
		if self._s != '':
			candidates = filter(lambda x: x['address'] == btc_address(self._s), candidates)
		# highest number of confirmations should be listed first as preferred spending account
		candidates = sorted(candidates, lambda x, y: cmp(y['confirmations'], x['confirmations']))
		input = []
		total = 0
		for c in candidates:
			if total < v + t:
				input.append({ 'txid' : btc_btolx(c['outpoint'].hash), 'vout' : c['outpoint'].n } )
				total += c['amount']
		if total < v:
			raise InsufficientFunds
		return (input, total)

	# returns a dict of { address : amount } outputs
	# if self._s == '', create a new change address, otherwise send change back to self._src
	def _o(self, s, v, t, input):
		output = { self._d : s - t if self._s == self._d else v }
		if self._s == '':
			output[self.proxy.getrawchangeaddress().__str__()] = s - v - t
		for k in output:
			output[k] = output[k] * 10 ** -8
		return output

	# creates the transaction to send
	# cf. http://bitcoin.stackexchange.com/questions/25224/what-is-a-step-by-step-way-to-insert-data-in-op-return for how to implement on TESTNET
	# cf. https://github.com/coinspark/php-OP_RETURN for implementation on MAINNET in PHP
	def _create(self, i, o):
		tx = RawTx(self.proxy, self.proxy.createrawtransaction(i, o))
		return tx

	# return txid
	# amt and tax are both in satoshi units
	def send(self, amt, tax):
		(i, s) = self._i(amt, tax)
		o = self._o(s, amt, tax, i)
		tx = self._create(i, o)

		# get the unpacked data and edit to suit our needs
		d = tx.unpack()

		# get the payload
		p = CScriptOp.encode_op_pushdata(self.msg)

		# append OP_RETURN tx out
		d['vout'].append({
			'value' : 0,
			'scriptPubKey' : RawTx.BinaryStream._unpack_hex(p) + '6a',
		})
		tx.pack(d)

		# here
		# signed, sealed, delivered
		# pprint(tx.unpack())
		# tx = RawTx(self.proxy, self.proxy.signrawtransaction(json.dumps(tx.unpack())))

		# pprint(tx.json)
		# print tx.json['txid']

# OPReturnTx('', '1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', 'Hello world!').send(1000, MIN_TAX)
OPReturnTx('1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', '1AU6kp7Cb5pmocQcVNqwdAbRq9HLwaZoW1', 'Hello').send(1000, MIN_TAX)

class BTCCDNCommand(object):
	global VERSION
	COMMAND = {
		'MSG' : 32,
		'FILESTART' : 33,
		'FILETERM' : 34,
		'TERMACCT' : 34
	}
	v = VERSION

	# cmd is a string input
	# payload is array (?)
	def __init__(self, cmd, payload):
		global MAX_LENGTH
		assert(cmd in self.COMMAND)
		# ? assert(len(payload) <= MAX_DATA - LEN_HEAD)
		self._c = self.COMMAND[cmd]
		self._p = payload

	@property
	def command(self):
		for k, v in self.COMMAND:
			if self._c == v:
				return k

	@property
	def payload(self):
		return self._p

	@property
	def header(self):
		return self.v << 5 | self._c
		

class AddrLog(object):
	global MIN_TAX
	tax = MIN_TAX
	def __init__(self, address):
		self._addr = address
		# if log file does not exist, create it, get count
		self.count = 0

	@property
	def count(self):
		return self._c

	@count.setter
	def count(self, v):
		self._c = v
		# write to file

	@property
	def address(self):
		return self._addr

	# return how much spending potential the current ADDRESS has
	@property
	def funds(self):
		return 0

	# sends data to destination address; if final = True, terminate this account
	def send(self, dest, data):
		# check insufficient funds

		# lock funds

		# send
		tx = []
		# for ...
		tx.append(OPReturnTx(self.address, dest, data[0::1]).send(0, self.tax))

		self.c += 0
		pass
		# unlock funds

	def term(self, next=''):
		# lock funds
		OPReturnTx(self.address, self.address, next).send(0, self.tax)
		pass
		# unlock funds

class File(object):
	def __init__(self, name):
		self._fn = name

	@property
	def name(self):
		return self._fn

	# returns the size of the file in bytes
	@property
	def size(self):
		return os.stat(self.name).st_size

	@property
	def data(self):
		return ''

	# sends self to the target address dest, with any leftover funds going to address change
	# throws NoFunds exception if insufficient funds
	# returns first txid of the transaction
	def send(self, change, dest):
		return AddrLog(change).send(dest, self.data)
